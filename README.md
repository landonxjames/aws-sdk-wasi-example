# NOTE THIS GUIDE IS A WORK IN PROGRESS AND NOT YET READY FOR CONSUMPTION

# Using Smithy-rs Clients in WebAssembly

## Introduction

WebAssembly (often abbreviated WASM) is a binary instruction format designed as a portable compilation target for high-level programming languages. It's a low level assembly-like language with a compact binary format that runs with near-native performance and provides languages with a compilation target that enables deployment on the web and in other language environments. WASM runtimes are sandboxed by default, only allowing access to the host environment via explicitly imported functions. The default sandboxing of WASM environments motivated the creation of the WebAssembly System Interface (WASI), a standardized interface that allows WebAssembly modules to interact with system resources outside of the WASM environment.

WebAssembly modules inherently support only primitive data types (integers and floats of various sizes). The WebAssembly Component Model addresses this limitation by standardizing complex interface definitions. These interfaces are specified using WebAssembly Interface Types (WIT), an interface description language that maps primitive WebAssembly types to a canonical ABI. When WIT metadata is embedded within a WebAssembly binary, it is called a WebAssembly Component, and the metadata allows host runtimes to generate bindings to the underlying module.

In this guide we will explore how to use the AWS SDK for Rust in a WASM component using the WASI HTTP interfaces. We are going to create a component that takes in binary data, and some arbitrary metadata. It will store the binary data in S3 and the metadata in DynamoDB. It will also support some basic querying capabilities. We will then generate Javascript and Python bindings to this module to show how it can be used in multiple host environments.

## Prerequisites

There are several tools you will need as you work through the examples in this guide:

- An up to date [Rust installation](https://www.rust-lang.org/tools/install)
- The [wasm32-wasip1 compilation target](https://doc.rust-lang.org/rustc/platform-support/wasm32-wasip1.html) which can be added with the command `rustup target add wasm32-wasip1`
- The [cargo-component build tool](https://crates.io/crates/cargo-component) which can be added with `cargo install cargo-component --locked`
- A working [NodeJS installation](https://nodejs.org/en/download)
- A working [Python installation](https://www.python.org/downloads/)

## Building our WASM Component

First we create a new Rust workspace to build our component in:

```
cargo component new --lib aws-sdk-wasi-example
```

This creates a new directory structured like this:

```
.
├── Cargo.toml
├── src
│   ├── bindings.rs
│   └── lib.rs
└── wit
    └── world.wit
```

Lets take a quick look at what each of these files does before we move on:

- **Cargo.toml:** The `Cargo.toml` file is the standard way of managing configuration and dependencies for Rust projects
- **src/[bindings.rs](http://bindings.rs/):** These bindings are autogenerated by `cargo-component` and will change as we update the `.wit` file. You will never need to update this file manually.
- **src/[lib.rs](http://lib.rs/):** This is the file where we will implement the business logic for our component. Currently it contains a simple Hello World program.
- **wit/world.wit:** This file contains the WIT definition of our component, currently it only exports the simple Hello World function defined in `lib.rs`.

We will first start by updating our WIT definition to model the component we want:

```
package component:aws-sdk-wasi-example;

interface data-uploader {
    resource data-uploader-client {
        constructor(config: client-config);
        upload: func(input: data) -> result<confirmation, error>;
        %list: func() -> result<list<file-metadata>, error>;
    }

    record client-config {
        region: string,
        bucket-name: string,
        table-name: string,
    }

    record data {
        file-name: string,
        data: list<u8>,
        metadata: list<tuple<string, string>>,
    }

    record confirmation {
        s3-uri: string,
    }

    record file-metadata {
        s3-uri: string,
        metadata: list<tuple<string, string>>,
    }

    variant error {
        s3-error(string),
        ddb-error(string),
        input-error(string),
    }
}

world example {
    export data-uploader;
}
```

You can see that we’ve added several things here:

- A new interface named `data-uploader` and a corresponding `export` statement in the `world` definition.
- Several types inside the interface, a `resource data-uploader-client` and a three `record` types.

Several of these WIT concepts are new, so we will review them here, but if you would like to take a more in depth look at the WIT language you can reference the [official guide](https://component-model.bytecodealliance.org/design/wit.html#results).

- Interface: In WIT an `interface` is a namespace that can contain types
- World: A WIT `world` describes the set of imports and exports of a WASM component
- Record: A `record` is a set of named fields, this is very similar to a Rust `struct`
- Resource: A `resource` is a handle to an entity that lives inside of the WASM component. It can hold state and exposes its behavior through methods. This is similar to a Class in many languages.
- Variant: A `variant` is similar to a Rust `enum`, it consists of a case and optionally some data contained by each case.

Now that we’ve updated our WIT definition we will need to update our `lib.rs` to implement it. With the `todo!()` macro filling in any business logic our basic implementation looks like this:

```
#[allow(warnings)]
mod bindings;

use bindings::exports::component::aws_sdk_wasi_example::data_uploader;
use bindings::exports::component::aws_sdk_wasi_example::data_uploader::Guest;
use bindings::exports::component::aws_sdk_wasi_example::data_uploader::GuestDataUploaderClient;

struct Component;

impl Guest for Component {
    type DataUploaderClient = DataUploaderClient;
}

struct DataUploaderClient;

impl GuestDataUploaderClient for DataUploaderClient {
    fn new(
        config: data_uploader::ClientConfig,
    ) -> Self {
        todo!()
    }

    fn upload(
        &self,
        input: data_uploader::Data,
    ) -> Result<data_uploader::Confirmation, data_uploader::Error> {
        todo!()
    }

    fn list(&self) -> Result<Vec<data_uploader::FileMetadata>, data_uploader::Error> {
        todo!()
    }
}

bindings::export!(Component with_types_in bindings);
```

You can see that we are importing two traits from the WIT generated `bindings` module, `Guest` and `GuestDataUploaderClient`. The `Guest` trait represents the `data-uploader` interface from the WIT definition, and the `GuestDataUploaderClient` trait represents the `data-uploader-client` resource. All of the record types in the interface are defined for us and can be found in the `bindings` module.

Now that we have seen the basic outline of our module we can begin filling in the business logic in the methods of the `GuestDataUploaderClient` trait. To do this we need to add some new dependencies for the Rust SDK crates. Add the following to the `[dependencies]` section of your `Cargo.toml`:

```
[dependencies]
wit-bindgen-rt = { version = "0.42.1", features = ["bitflags"] }
aws-sdk-s3 = {version = "1", default-features = false}
aws-sdk-dynamodb = {version = "1", default-features = false}
aws-config = {version = "1", default-features = false}
aws-smithy-async = { version = "1", default-features = false, features = ["rt-tokio"]}
aws-smithy-wasm = "0.1.4"
tokio = { version = "1.45.0", features = ["macros", "rt", "time"] }
```

Notice that we have set `default-features = false` for most of the `aws-*` crates. This is because some of the default features, like the default HTTPS client will not work in WASM environments.

With these dependencies added we will now implement the `new` method for our `GuestDataUploaderClient` trait.

```
struct DataUploaderClient {
    s3_client: aws_sdk_s3::Client,
    ddb_client: aws_sdk_dynamodb::Client,
    bucket_name: String,
    table_name: String,
    runtime: tokio::runtime::Runtime,
}


fn new(
        config: bindings::exports::component::aws_sdk_wasi_example::data_uploader::ClientConfig,
    ) -> Self {
        let runtime = tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()
            .expect("Failed to generate tokio runtime");

        let http_client = aws_smithy_wasm::wasi::WasiHttpClientBuilder::new().build();
        let sleep = aws_smithy_async::rt::sleep::TokioSleep::new();

        let aws_config = runtime.block_on(async {
            aws_config::defaults(BehaviorVersion::latest())
                .region(Region::new(config.region))
                .http_client(http_client)
                .sleep_impl(sleep)
                .load()
                .await
        });
        let s3_client = aws_sdk_s3::Client::new(&aws_config);
        let ddb_client = aws_sdk_dynamodb::Client::new(&aws_config);

        Self {
            s3_client,
            ddb_client,
            bucket_name: config.bucket_name,
            table_name: config.table_name,
            runtime,
        }
    }
```

There are several things created in this function, all of which are stored in the struct `DataUploaderClient`. The first is a `tokio` `Runtime` which we will use to run the `async` tasks required by the SDK. WIT does not currently support modeling `async` functions, so we have to manually manage the runtime ourselves (support for async functions is planned for the upcoming [WASI 0.3 release](https://wasi.dev/roadmap#upcoming-wasi-03-releases)). We then create a `SdkConfig` that we use to instantiate the S3 and DDB clients. Note that we pass a customer `http_client` from the `aws_smithy_wasm` crate and a custom `sleep_impl` to this config. Both are necessary for the clients to work in WASM environments. All of these objects, plus the `bucket_name` and `table_name` from the input config, are stored on the `DataUploaderClient`.

With our `data-uploader-client` created we can now implement its `upload` and `list` functions.

```
    fn upload(
        &self,
        input: data_uploader::Data,
    ) -> Result<data_uploader::Confirmation, data_uploader::Error> {
        let _s3_res = self.runtime.block_on(async {
            self.s3_client
                .put_object()
                .bucket(&self.bucket_name)
                .key(&input.file_name)
                .body(input.data.into())
                .send()
                .await
                .map_err(|e| data_uploader::Error::S3Error(e.to_string()))
        })?;

        let s3_uri = format!("s3://{}/{}", self.bucket_name, input.file_name);

        let mut metadata: HashMap<String, aws_sdk_dynamodb::types::AttributeValue> = input
            .metadata
            .iter()
            .map(|(key, val)| {
                (
                    key.clone(),
                    aws_sdk_dynamodb::types::AttributeValue::S(val.clone()),
                )
            })
            .collect();

        if existing_s3_uri.is_some() {
            return Err(data_uploader::Error::InputError(
                "s3_uri is a reserved metadata key".into(),
            ));
        }

        if existing_s3_uri.is_some() {
            return Err(data_uploader::Error::DdbError(
                "s3_uri is a reserved metadata key".into(),
            ));
        }

        let _ddb_res = self.runtime.block_on(async {
            self.ddb_client
                .put_item()
                .table_name(&self.table_name)
                .set_item(Some(metadata))
                .send()
                .await
                .map_err(|e| data_uploader::Error::DdbError(e.to_string()))
        })?;

        Ok(data_uploader::Confirmation { s3_uri })
    }

    fn list(&self) -> Result<Vec<data_uploader::FileMetadata>, data_uploader::Error> {
        let filter_exp = "attribute_exists(s3_uri)".to_string();

        let ddb_res = self.runtime.block_on(async {
            self.ddb_client
                .scan()
                .table_name(&self.table_name)
                .filter_expression(filter_exp)
                .into_paginator()
                .send()
                .try_collect()
                .await
                .into_iter()
                .flatten()
                .map(|scan_out| {
                    // Combine all of the items into a single HashMap
                    let items = scan_out.items.unwrap_or_default();
                    let mut items: HashMap<&String, &AttributeValue> = items
                        .iter()
                        .flat_map(|item| item.iter().collect::<Vec<(&String, &AttributeValue)>>())
                        .collect();

                    #[allow(clippy::unnecessary_to_owned)]
                    let s3_uri = items
                        .remove(&"s3_uri".to_string())
                        .ok_or(data_uploader::Error::DdbError(
                            "s3_uri not found in DDB item".into(),
                        ))?
                        .as_s()
                        .map_err(|_| {
                            data_uploader::Error::DdbError("s3_uri is not a string".into())
                        })?
                        .clone();

                    let metadata = items
                        .into_iter()
                        .map(|(key, val)| {
                            let mapped_val = val.as_s().map_err(|_| {
                                data_uploader::Error::DdbError(format!(
                                    "metadata key {key} not a string"
                                ))
                            });

                            if let Err(err) = mapped_val {
                                Err(err)
                            } else {
                                Ok((key.clone(), mapped_val.unwrap().clone()))
                            }
                        })
                        .collect::<Result<Vec<(String, String)>, data_uploader::Error>>()?;

                    Ok(data_uploader::FileMetadata { s3_uri, metadata })
                })
                .collect::<Result<Vec<_>, _>>()
        });

        ddb_res
    }
```

Both of these functions make use of the SDK clients we created in the `new()` method to interact with AWS services inside your WASM component.

If we now run `cargo component build --release` we will see our WASM component in our workspace at `target/wasm32-wasip1/release/aws_sdk_wasi_example.wasm`. Note that this file is about 6MB. We typically want to get our WASM binaries as small as possible to improve distribution and compile times. We can improve the size of our artifact by adding a few setting in our Cargo.toml file:

```
[profile.release]
codegen-units = 1
opt-level = "s"
debug = false
strip = true
lto = true
```

We won’t go into depth on what each of these settings do, but you can read more about them in the [Profiles section](https://doc.rust-lang.org/cargo/reference/profiles.html) of the Cargo reference manual. After adding these settings and re-running `cargo component build --release` our WASM binary is now around 3MB, a 50% decrease from before.

## Building Bindings

With all of our business logic completed we can now create bindings to our WASM component for Javascript and Python.

### Javascript

To create Javascript bindings to our WASM module we will use [jco](https://www.npmjs.com/package/@bytecodealliance/jco), a tool that generates bindings and inserts Javascript implementations of the WASI interfaces since most JS runtimes do not currently provide a WASI runtime environment. At the root of your project create a new file called `package.json` and copy the following into it:

```
{
  "name": "aws-sdk-wasi-example",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "build-js-bindings": "cargo component build --release && npx jco transpile ./target/wasm32-wasip1/release/aws_sdk_wasi_example.wasm -o ./js-bindings/ --no-namespaced-exports",
    "build": "npm run build-js-bindings"
  },
  "devDependencies": {
    "@bytecodealliance/jco": "^1.11.2"
  },
  "dependencies": {
    "@bytecodealliance/preview2-shim": "^0.17.2"
  }
}
```

Then run `npm install && npm run build`. This will create a new folder in your project called `js-bindings` containing the javascript bindings to the WASM component and typescript types describing the interfaces. You can see that the types generated for our `data-uploader` interface in `js-bindings/interfaces/component-aws-sdk-wasi-example-data-uploader.d.ts` closely mirror what we described in the WIT file.

```
export interface ClientConfig {
  region: string,
  bucketName: string,
  tableName: string,
}
export interface Data {
  fileName: string,
  data: Uint8Array,
  metadata: Array<[string, string]>,
}
export interface Confirmation {
  s3Uri: string,
}
export interface FileMetadata {
  s3Uri: string,
  metadata: Array<[string, string]>,
}
export type Error = ErrorS3Error | ErrorDdbError | ErrorInputError;
export interface ErrorS3Error {
  tag: 's3-error',
  val: string,
}
export interface ErrorDdbError {
  tag: 'ddb-error',
  val: string,
}
export interface ErrorInputError {
  tag: 'input-error',
  val: string,
}

export class DataUploaderClient {
  constructor(config: ClientConfig)
  upload(input: Data): Confirmation;
  list(): Array<FileMetadata>;
}
```

Now to use these generated bindings create another file at the root of your project called `main.ts` and add the following content to it:

```
import * as component from "./js-bindings/aws_sdk_wasi_example.js";
import {
  ClientConfig,
  Data,
} from "./js-bindings/interfaces/component-aws-sdk-wasi-example-data-uploader.js";

let config: ClientConfig = {
  region: "us-west-2",
  bucketName: "aws-sdk-wasi-example-bucket",
  tableName: "aws-sdk-wasi-example-table",
};

let client = new component.dataUploader.DataUploaderClient(config);

let data: Data = {
  fileName: "test.txt",
  data: new TextEncoder().encode("Hello, World!"),
  metadata: [
    ["key1", "value1"],
    ["key2", "value2"],
  ],
};

let fileLocation = client.upload(data);
console.log("fileLocation:", fileLocation);

let uploadedFiles = client.list();
console.log("uploadedFiles:", JSON.stringify(uploadedFiles));
```

Before running this code we need to make sure that we have appropriate credentials available in our environment that have permissions to write to S3 and DDB. To easily achieve this we will export our credentials as environment variables using the following command:

```
export AWS_ACCESS_KEY_ID=<YOUR_ACCESS_KEY_ID_HERE>
export AWS_SECRET_ACCESS_KEY=<YOUR_SECRET_ACCESS_KEY_HERE>
export AWS_SESSION_TOKEN=<YOUR_SESSION_TOKEN_HERE>
```

With all of the setup complete we can now run our Javascript code with `npx tsx main.ts`. It should give the following output:

```
fileLocation: { s3Uri: 's3://aws-sdk-wasi-example-bucket/test.txt' }
uploadedFiles: [{"s3Uri":"s3://aws-sdk-wasi-example-table/test.txt","metadata":[["key2","value2"],["key1","value1"]]}]
```

### Python

To create our Python bindings we will use the [wasmtime](https://pypi.org/project/wasmtime/) package which provides bindings to the open source [wasmtime runtime](https://wasmtime.dev/). To begin we will create a new file at the root of our project named `requirements.txt` with the following content:

```
wasmtime==33.0.0
```

We then run `pip install -r requirements.txt` to install our wasmtime dependency. Then to generate the python bindings for our component we run `python -m wasmtime.bindgen ./target/wasm32-wasip1/release/aws_sdk_wasi_example.wasm --out-dir py-bindings/`

TODO: Found a bug in the python binding generator: https://github.com/bytecodealliance/wasmtime-py/issues/282
